"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.noTransformation = void 0;
const proto_1 = require("@xmtp/proto");
const noTransformation = (msg) => {
    return msg;
};
exports.noTransformation = noTransformation;
/**
 * Stream implements an Asynchronous Iterable over messages received from a topic.
 * As such can be used with constructs like for-await-of, yield*, array destructing, etc.
 */
class Stream {
    constructor(client, topics, messageTransformer, messageFilter, contentTopicUpdater) {
        this.messages = [];
        this.resolvers = [];
        this.topics = topics;
        this.client = client;
        this.callback = this.newMessageCallback(messageTransformer, messageFilter, contentTopicUpdater);
    }
    // returns new closure to handle incoming messages
    newMessageCallback(transformer, filter, contentTopicUpdater) {
        return (env) => __awaiter(this, void 0, void 0, function* () {
            if (!env.message) {
                return;
            }
            const msg = yield this.client.decodeMessage(proto_1.fetcher.b64Decode(env.message), env.contentTopic);
            // If there is a filter on the stream, and the filter returns false, ignore the message
            if (filter && !filter(msg)) {
                return;
            }
            // Check to see if we should update the stream's content topic subscription
            if (contentTopicUpdater) {
                const topics = contentTopicUpdater(msg);
                if (topics) {
                    this.resubscribeToTopics(topics);
                }
            }
            // is there a Promise already pending?
            const resolver = this.resolvers.pop();
            if (resolver) {
                // yes, resolve it
                resolver({ value: transformer(msg) });
            }
            else {
                // no, push the message into the queue
                this.messages.unshift(transformer(msg));
            }
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.callback) {
                throw new Error('Missing callback for stream');
            }
            this.unsubscribeFn = this.client.apiClient.subscribe({
                contentTopics: this.topics,
            }, (env) => __awaiter(this, void 0, void 0, function* () {
                if (!this.callback)
                    return;
                yield (this === null || this === void 0 ? void 0 : this.callback(env));
            }));
        });
    }
    static create(client, topics, messageTransformer, messageFilter, contentTopicUpdater) {
        return __awaiter(this, void 0, void 0, function* () {
            const stream = new Stream(client, topics, messageTransformer, messageFilter, contentTopicUpdater);
            yield stream.start();
            return stream;
        });
    }
    // To make Stream proper Async Iterable
    [Symbol.asyncIterator]() {
        return this;
    }
    // return should be called if the interpreter detects that the stream won't be used anymore,
    // e.g. a for/of loop was exited via a break. It can also be called explicitly.
    // https://tc39.es/ecma262/#table-iterator-interface-optional-properties
    // Note that this means the Stream will be closed after it was used in a for-await-of or yield* or similar.
    return() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.unsubscribeFn) {
                yield this.unsubscribeFn();
            }
            if (!this.callback) {
                return { value: undefined, done: true };
            }
            this.callback = undefined;
            this.resolvers.forEach((resolve) => resolve({ value: undefined, done: true }));
            return { value: undefined, done: true };
        });
    }
    // To make Stream proper Async Iterator
    // Note that next() will still provide whatever messages were already pending
    // even after the stream was closed via return().
    next() {
        // Is there a message already pending?
        const msg = this.messages.pop();
        if (msg) {
            // yes, return resolved promise
            return Promise.resolve({ value: msg });
        }
        if (!this.callback) {
            return Promise.resolve({ value: undefined, done: true });
        }
        // otherwise return empty Promise and queue its resolver
        return new Promise((resolve) => this.resolvers.unshift(resolve));
    }
    // Unsubscribe from the existing content topics and resubscribe to the given topics.
    resubscribeToTopics(topics) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.callback || !this.unsubscribeFn) {
                throw new Error('Missing callback for stream');
            }
            yield this.unsubscribeFn();
            this.topics = topics;
            this.unsubscribeFn = this.client.apiClient.subscribe({
                contentTopics: this.topics,
            }, (env) => __awaiter(this, void 0, void 0, function* () {
                if (!this.callback)
                    return;
                yield (this === null || this === void 0 ? void 0 : this.callback(env));
            }));
        });
    }
}
exports.default = Stream;
//# sourceMappingURL=Stream.js.map