"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultOptions = exports.Compression = exports.KeyStoreType = exports.ApiUrls = void 0;
const crypto_1 = require("./crypto");
const Message_1 = __importDefault(require("./Message"));
const utils_1 = require("./utils");
const Stream_1 = __importStar(require("./Stream"));
const store_1 = require("./store");
const conversations_1 = require("./conversations");
const Text_1 = require("./codecs/Text");
const MessageContent_1 = require("./MessageContent");
const Compression_1 = require("./Compression");
const proto_1 = require("@xmtp/proto");
const ContactBundle_1 = __importDefault(require("./ContactBundle"));
const ApiClient_1 = __importDefault(require("./ApiClient"));
const authn_1 = require("./authn");
const { Compression } = proto_1.xmtpEnvelope;
exports.Compression = Compression;
const { b64Decode } = proto_1.fetcher;
// eslint-disable @typescript-eslint/explicit-module-boundary-types
// eslint-disable @typescript-eslint/no-explicit-any
// Default maximum allowed content size
const MaxContentSize = 100 * 1024 * 1024; // 100M
exports.ApiUrls = {
    local: 'http://localhost:5555',
    dev: 'https://dev.xmtp.network',
    production: 'https://production.xmtp.network',
};
var KeyStoreType;
(function (KeyStoreType) {
    KeyStoreType[KeyStoreType["networkTopicStoreV1"] = 0] = "networkTopicStoreV1";
    KeyStoreType[KeyStoreType["localStorage"] = 1] = "localStorage";
    KeyStoreType[KeyStoreType["static"] = 2] = "static";
})(KeyStoreType = exports.KeyStoreType || (exports.KeyStoreType = {}));
/**
 * Provide a default client configuration. These settings can be used on their own, or as a starting point for custom configurations
 *
 * @param opts additional options to override the default settings
 */
function defaultOptions(opts) {
    const _defaultOptions = {
        keyStoreType: KeyStoreType.networkTopicStoreV1,
        privateKeyOverride: undefined,
        env: 'dev',
        apiUrl: undefined,
        codecs: [new Text_1.TextCodec()],
        maxContentSize: MaxContentSize,
    };
    if (opts === null || opts === void 0 ? void 0 : opts.codecs) {
        opts.codecs = _defaultOptions.codecs.concat(opts.codecs);
    }
    if ((opts === null || opts === void 0 ? void 0 : opts.privateKeyOverride) && !(opts === null || opts === void 0 ? void 0 : opts.keyStoreType)) {
        opts.keyStoreType = KeyStoreType.static;
    }
    return Object.assign(Object.assign({}, _defaultOptions), opts);
}
exports.defaultOptions = defaultOptions;
/**
 * Client class initiates connection to the XMTP network.
 * Should be created with `await Client.create(options)`
 */
class Client {
    constructor(keys, apiClient) {
        this.contacts = new Set();
        this.knownPublicKeyBundles = new Map();
        this.keys = keys;
        this.address = keys.identityKey.publicKey.walletSignatureAddress();
        this._conversations = new conversations_1.Conversations(this);
        this._codecs = new Map();
        this._maxContentSize = MaxContentSize;
        this.apiClient = apiClient;
    }
    /**
     * @type {Conversations}
     */
    get conversations() {
        return this._conversations;
    }
    /**
     * Create and start a client associated with given wallet.
     *
     * @param wallet the wallet as a Signer instance
     * @param opts specify how to to connect to the network
     */
    static create(wallet, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const options = defaultOptions(opts);
            const apiClient = createApiClientFromOptions(options);
            const keys = yield loadOrCreateKeysFromOptions(options, wallet, apiClient);
            apiClient.setAuthenticator(new authn_1.Authenticator(keys.identityKey));
            const client = new Client(keys, apiClient);
            yield client.init(options);
            return client;
        });
    }
    static getKeys(wallet, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield Client.create(wallet, opts);
            return client.keys.encode();
        });
    }
    init(options) {
        return __awaiter(this, void 0, void 0, function* () {
            options.codecs.forEach((codec) => {
                this.registerCodec(codec);
            });
            this._maxContentSize = options.maxContentSize;
            yield this.publishUserContact();
        });
    }
    // gracefully shut down the client
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            return undefined;
        });
    }
    // publish the key bundle into the contact topic
    publishUserContact() {
        return __awaiter(this, void 0, void 0, function* () {
            const pub = this.keys.getPublicKeyBundle();
            yield this.publishEnvelope({
                contentTopic: (0, utils_1.buildUserContactTopic)(this.address),
                message: pub.toBytes(),
            });
        });
    }
    // retrieve a key bundle from given user's contact topic
    getUserContactFromNetwork(peerAddress) {
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function* () {
            // have to avoid undefined to not trip TS's strictNullChecks on recipientKey
            let recipientKey = null;
            const stream = this.apiClient.queryIterator({ contentTopics: [(0, utils_1.buildUserContactTopic)(peerAddress)] }, { pageSize: 5 });
            try {
                for (var stream_1 = __asyncValues(stream), stream_1_1; stream_1_1 = yield stream_1.next(), !stream_1_1.done;) {
                    const env = stream_1_1.value;
                    if (!env.message)
                        continue;
                    const bundle = ContactBundle_1.default.fromBytes(b64Decode(env.message.toString()));
                    const keyBundle = bundle.keyBundle;
                    const address = keyBundle === null || keyBundle === void 0 ? void 0 : keyBundle.walletSignatureAddress();
                    if (address === peerAddress) {
                        recipientKey = keyBundle;
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (stream_1_1 && !stream_1_1.done && (_a = stream_1.return)) yield _a.call(stream_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return recipientKey === null ? undefined : recipientKey;
        });
    }
    /**
     * Returns the cached PublicKeyBundle if one is known for the given address or fetches
     * one from the network
     */
    getUserContact(peerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const existingBundle = this.knownPublicKeyBundles.get(peerAddress);
            if (existingBundle) {
                return existingBundle;
            }
            const newBundle = yield this.getUserContactFromNetwork(peerAddress);
            if (newBundle) {
                this.knownPublicKeyBundles.set(peerAddress, newBundle);
            }
            return newBundle;
        });
    }
    /**
     * Check if @peerAddress can be messaged, specifically it checks that a PublicKeyBundle can be
     * found for the given address
     */
    canMessage(peerAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const keyBundle = yield this.getUserContact(peerAddress);
            return keyBundle !== undefined;
        });
    }
    /**
     * Send a message to the wallet identified by @peerAddress
     */
    sendMessage(peerAddress, content, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let topics;
            const recipient = yield this.getUserContact(peerAddress);
            if (!recipient) {
                throw new Error(`recipient ${peerAddress} is not registered`);
            }
            if (!this.contacts.has(peerAddress)) {
                topics = [
                    (0, utils_1.buildUserIntroTopic)(peerAddress),
                    (0, utils_1.buildDirectMessageTopic)(this.address, peerAddress),
                ];
                if (peerAddress !== this.address) {
                    topics.push((0, utils_1.buildUserIntroTopic)(this.address));
                }
                this.contacts.add(peerAddress);
            }
            else {
                topics = [(0, utils_1.buildDirectMessageTopic)(this.address, peerAddress)];
            }
            const timestamp = (options === null || options === void 0 ? void 0 : options.timestamp) || new Date();
            const msg = yield this.encodeMessage(recipient, timestamp, content, options);
            const msgBytes = msg.toBytes();
            yield Promise.all(topics.map((topic) => __awaiter(this, void 0, void 0, function* () {
                return this.publishEnvelope({
                    contentTopic: topic,
                    message: msgBytes,
                });
            })));
            return this.decodeMessage(msgBytes, topics[0]);
        });
    }
    publishEnvelope(env) {
        return __awaiter(this, void 0, void 0, function* () {
            const bytes = env.message;
            if (!env.contentTopic) {
                throw new Error('Missing content topic');
            }
            if (!bytes || !bytes.length) {
                throw new Error('Cannot publish empty message');
            }
            try {
                yield this.apiClient.publish([
                    {
                        contentTopic: env.contentTopic,
                        message: bytes,
                    },
                ]);
            }
            catch (err) {
                console.log(err);
            }
        });
    }
    registerCodec(codec) {
        const id = codec.contentType;
        const key = `${id.authorityId}/${id.typeId}`;
        this._codecs.set(key, codec);
    }
    codecFor(contentType) {
        const key = `${contentType.authorityId}/${contentType.typeId}`;
        const codec = this._codecs.get(key);
        if (!codec) {
            return undefined;
        }
        if (contentType.versionMajor > codec.contentType.versionMajor) {
            return undefined;
        }
        return codec;
    }
    encodeMessage(recipient, timestamp, content, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const contentType = (options === null || options === void 0 ? void 0 : options.contentType) || Text_1.ContentTypeText;
            const codec = this.codecFor(contentType);
            if (!codec) {
                throw new Error('unknown content type ' + contentType);
            }
            const encoded = codec.encode(content, this);
            if (options === null || options === void 0 ? void 0 : options.contentFallback) {
                encoded.fallback = options.contentFallback;
            }
            if (options === null || options === void 0 ? void 0 : options.compression) {
                encoded.compression = options.compression;
            }
            yield (0, Compression_1.compress)(encoded);
            const payload = proto_1.xmtpEnvelope.EncodedContent.encode(encoded).finish();
            return Message_1.default.encode(this.keys, recipient, payload, timestamp);
        });
    }
    decodeMessage(payload, contentTopic) {
        return __awaiter(this, void 0, void 0, function* () {
            const message = yield Message_1.default.decode(this.keys, payload);
            if (message.error) {
                return message;
            }
            if (!message.decrypted) {
                throw new Error('decrypted bytes missing');
            }
            const encoded = proto_1.xmtpEnvelope.EncodedContent.decode(message.decrypted);
            yield (0, Compression_1.decompress)(encoded, this._maxContentSize);
            if (!encoded.type) {
                throw new Error('missing content type');
            }
            const contentType = new MessageContent_1.ContentTypeId(encoded.type);
            const codec = this.codecFor(contentType);
            message.contentTopic = contentTopic;
            if (codec) {
                message.content = codec.decode(encoded, this);
                message.contentType = contentType;
            }
            else {
                message.error = new Error('unknown content type ' + contentType);
                if (encoded.fallback) {
                    message.content = encoded.fallback;
                    message.contentType = MessageContent_1.ContentTypeFallback;
                }
            }
            return message;
        });
    }
    streamIntroductionMessages() {
        return Stream_1.default.create(this, [(0, utils_1.buildUserIntroTopic)(this.address)], Stream_1.noTransformation);
    }
    streamConversationMessages(peerAddress) {
        const topics = [(0, utils_1.buildDirectMessageTopic)(peerAddress, this.address)];
        return Stream_1.default.create(this, topics, Stream_1.noTransformation, filterForTopics(topics));
    }
    // list stored messages from this wallet's introduction topic
    listIntroductionMessages(opts) {
        return this.listMessages((0, utils_1.buildUserIntroTopic)(this.address), opts);
    }
    // list stored messages from conversation topic with the peer
    listConversationMessages(peerAddress, opts) {
        return this.listMessages((0, utils_1.buildDirectMessageTopic)(peerAddress, this.address), Object.assign(Object.assign({}, opts), { checkAddresses: true }));
    }
    // list stored messages from the specified topic
    listMessages(topic, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!opts) {
                opts = {};
            }
            const { startTime, endTime, checkAddresses, limit } = opts;
            const res = yield this.apiClient.query({ contentTopics: [topic], startTime, endTime }, {
                direction: proto_1.messageApi.SortDirection.SORT_DIRECTION_ASCENDING,
                limit,
            });
            let msgs = [];
            for (const env of res) {
                if (!env.message)
                    continue;
                try {
                    const msg = yield this.decodeMessage(b64Decode(env.message), env.contentTopic);
                    msgs.push(msg);
                }
                catch (e) {
                    console.log(e);
                }
            }
            if (checkAddresses) {
                msgs = msgs.filter(filterForTopics([topic]));
            }
            return msgs;
        });
    }
}
exports.default = Client;
function createKeyStoreFromConfig(opts, wallet, apiClient) {
    switch (opts.keyStoreType) {
        case KeyStoreType.networkTopicStoreV1:
            if (!wallet) {
                throw new Error('Must provide a wallet for networkTopicStore');
            }
            return createNetworkPrivateKeyStore(wallet, apiClient);
        case KeyStoreType.localStorage:
            if (!wallet) {
                throw new Error('Must provide a wallet for localStorageStore');
            }
            return createLocalPrivateKeyStore(wallet);
        case KeyStoreType.static:
            if (!opts.privateKeyOverride) {
                throw new Error('Must provide a privateKeyOverride to use static store');
            }
            return createStaticStore(opts.privateKeyOverride);
    }
}
// Create Encrypted store which uses the Network to store KeyBundles
function createNetworkPrivateKeyStore(wallet, apiClient) {
    return new store_1.EncryptedStore(wallet, new store_1.PrivateTopicStore(apiClient));
}
// Create Encrypted store which uses LocalStorage to store KeyBundles
function createLocalPrivateKeyStore(wallet) {
    return new store_1.EncryptedStore(wallet, new store_1.LocalStorageStore());
}
function createStaticStore(privateKeyOverride) {
    return new store_1.StaticKeyStore(privateKeyOverride);
}
// attempt to load pre-existing key bundle from storage,
// otherwise create new key-bundle, store it and return it
function loadOrCreateKeysFromStore(wallet, store) {
    return __awaiter(this, void 0, void 0, function* () {
        let keys = yield store.loadPrivateKeyBundle();
        if (keys) {
            return keys;
        }
        if (!wallet) {
            throw new Error('No wallet found');
        }
        keys = yield crypto_1.PrivateKeyBundle.generate(wallet);
        yield store.storePrivateKeyBundle(keys);
        return keys;
    });
}
function loadOrCreateKeysFromOptions(options, wallet, apiClient) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!options.privateKeyOverride && !wallet) {
            throw new Error('Must provide either an ethers.Signer or specify privateKeyOverride');
        }
        const keyStore = createKeyStoreFromConfig(options, wallet, apiClient);
        return loadOrCreateKeysFromStore(wallet, keyStore);
    });
}
// Ensure the message didn't have a spoofed address
function filterForTopics(topics) {
    return (msg) => {
        const senderAddress = msg.senderAddress;
        const recipientAddress = msg.recipientAddress;
        return (senderAddress !== undefined &&
            recipientAddress !== undefined &&
            topics.includes((0, utils_1.buildDirectMessageTopic)(senderAddress, recipientAddress)));
    };
}
function createApiClientFromOptions(options) {
    const apiUrl = options.apiUrl || exports.ApiUrls[options.env];
    return new ApiClient_1.default(apiUrl);
}
//# sourceMappingURL=Client.js.map