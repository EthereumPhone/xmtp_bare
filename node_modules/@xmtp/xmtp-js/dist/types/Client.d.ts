import { PublicKeyBundle, PrivateKeyBundle } from './crypto';
import Message from './Message';
import Stream from './Stream';
import { Signer } from 'ethers';
import { Conversations } from './conversations';
import { ContentTypeId, ContentCodec } from './MessageContent';
import { xmtpEnvelope, messageApi } from '@xmtp/proto';
import ApiClient from './ApiClient';
declare const Compression: typeof xmtpEnvelope.Compression;
export declare const ApiUrls: {
    readonly local: "http://localhost:5555";
    readonly dev: "https://dev.xmtp.network";
    readonly production: "https://production.xmtp.network";
};
export declare type ListMessagesOptions = {
    checkAddresses?: boolean;
    startTime?: Date;
    endTime?: Date;
    limit?: number;
};
export declare enum KeyStoreType {
    networkTopicStoreV1 = 0,
    localStorage = 1,
    static = 2
}
export { Compression };
export declare type SendOptions = {
    contentType?: ContentTypeId;
    contentFallback?: string;
    compression?: xmtpEnvelope.Compression;
    timestamp?: Date;
};
/**
 * Network startup options
 */
declare type NetworkOptions = {
    env: keyof typeof ApiUrls;
    apiUrl: string | undefined;
};
declare type ContentOptions = {
    codecs: ContentCodec<any>[];
    maxContentSize: number;
};
declare type KeyStoreOptions = {
    /** Specify the keyStore which should be used for loading or saving privateKeyBundles */
    keyStoreType: KeyStoreType;
    privateKeyOverride?: Uint8Array;
};
/**
 * Aggregate type for client options. Optional properties are used when the default value is calculated on invocation, and are computed
 * as needed by each function. All other defaults are specified in defaultOptions.
 */
export declare type ClientOptions = NetworkOptions & KeyStoreOptions & ContentOptions;
/**
 * Provide a default client configuration. These settings can be used on their own, or as a starting point for custom configurations
 *
 * @param opts additional options to override the default settings
 */
export declare function defaultOptions(opts?: Partial<ClientOptions>): ClientOptions;
/**
 * Client class initiates connection to the XMTP network.
 * Should be created with `await Client.create(options)`
 */
export default class Client {
    address: string;
    keys: PrivateKeyBundle;
    apiClient: ApiClient;
    private contacts;
    private knownPublicKeyBundles;
    private _conversations;
    private _codecs;
    private _maxContentSize;
    constructor(keys: PrivateKeyBundle, apiClient: ApiClient);
    /**
     * @type {Conversations}
     */
    get conversations(): Conversations;
    /**
     * Create and start a client associated with given wallet.
     *
     * @param wallet the wallet as a Signer instance
     * @param opts specify how to to connect to the network
     */
    static create(wallet: Signer | null, opts?: Partial<ClientOptions>): Promise<Client>;
    static getKeys(wallet: Signer | null, opts?: Partial<ClientOptions>): Promise<Uint8Array>;
    init(options: ClientOptions): Promise<void>;
    close(): Promise<void>;
    private publishUserContact;
    getUserContactFromNetwork(peerAddress: string): Promise<PublicKeyBundle | undefined>;
    /**
     * Returns the cached PublicKeyBundle if one is known for the given address or fetches
     * one from the network
     */
    getUserContact(peerAddress: string): Promise<PublicKeyBundle | undefined>;
    /**
     * Check if @peerAddress can be messaged, specifically it checks that a PublicKeyBundle can be
     * found for the given address
     */
    canMessage(peerAddress: string): Promise<boolean>;
    /**
     * Send a message to the wallet identified by @peerAddress
     */
    sendMessage(peerAddress: string, content: any, options?: SendOptions): Promise<Message>;
    publishEnvelope(env: messageApi.Envelope): Promise<void>;
    registerCodec(codec: ContentCodec<any>): void;
    codecFor(contentType: ContentTypeId): ContentCodec<any> | undefined;
    encodeMessage(recipient: PublicKeyBundle, timestamp: Date, content: any, options?: SendOptions): Promise<Message>;
    decodeMessage(payload: Uint8Array, contentTopic: string | undefined): Promise<Message>;
    streamIntroductionMessages(): Promise<Stream<Message>>;
    streamConversationMessages(peerAddress: string): Promise<Stream<Message>>;
    listIntroductionMessages(opts?: ListMessagesOptions): Promise<Message[]>;
    listConversationMessages(peerAddress: string, opts?: ListMessagesOptions): Promise<Message[]>;
    private listMessages;
}
