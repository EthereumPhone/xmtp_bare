import { UnsubscribeFn } from './ApiClient';
import Message from './Message';
import Client from './Client';
import { messageApi } from '@xmtp/proto';
export declare type MessageTransformer<T> = (msg: Message) => T;
export declare type MessageFilter = (msg: Message) => boolean;
export declare type ContentTopicUpdater = (msg: Message) => string[] | undefined;
export declare const noTransformation: (msg: Message) => Message;
/**
 * Stream implements an Asynchronous Iterable over messages received from a topic.
 * As such can be used with constructs like for-await-of, yield*, array destructing, etc.
 */
export default class Stream<T> {
    topics: string[];
    client: Client;
    messages: T[];
    resolvers: ((value: IteratorResult<T>) => void)[];
    callback: ((env: messageApi.Envelope) => Promise<void>) | undefined;
    unsubscribeFn?: UnsubscribeFn;
    constructor(client: Client, topics: string[], messageTransformer: MessageTransformer<T>, messageFilter?: MessageFilter, contentTopicUpdater?: ContentTopicUpdater);
    private newMessageCallback;
    private start;
    static create<T>(client: Client, topics: string[], messageTransformer: MessageTransformer<T>, messageFilter?: MessageFilter, contentTopicUpdater?: ContentTopicUpdater): Promise<Stream<T>>;
    [Symbol.asyncIterator](): AsyncIterableIterator<T>;
    return(): Promise<IteratorResult<T>>;
    next(): Promise<IteratorResult<T>>;
    private resubscribeToTopics;
}
